11 - Select Case?
Glównym tematem tej lekcji bedzie instrukcja Select Case, która jest swego rodzaju odmiana instrukcji warunkowej, przeznaczona do obslugi warunków z bardzo duzo iloscia mozliwych wariantów.

Oprócz tego, podczas tej lekcji poznamy wreszcie wielokrotnie juz wspominane wyliczenia.

Lekcja zostala podzielona na nastepujace czesci:
Instrukcja Select Case
Laczenie kilku wartosci w pojedynczym bloku Case
Wykorzystanie zakresów w blokach Case
Zagniezdzanie instrukcji Select Case
Wyliczenia
Instrukcja Select Case
Aby dobrze zrozumiec istote instrukcji Select Case, powinienes sie najpierw zapoznac z przykladowym kodem, w którym instrukcja ta bylaby idealnym rozwiazaniem, jednak zamiast niej uzyto tradycyjnej instrukcji warunkowej If ... Then.

Ponizsza funkcja zwraca nazwe miesiaca w zaleznosci od numeru miesiaca podanego jako argument numer (jak zapewne pamietasz z lekcji o funkcjach wbudowanych, VBA posiada w swoim repertuarze funkcje wykonujaca to zadanie, wiec nie ma potrzeby pisania jej na nowo, jednak na potrzeby tej lekcji zostanie uczyniony wyjatek).

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
Function nazwaMiesiaca(numer As Integer) As String

    If numer = 1 Then
        nazwaMiesiaca = "styczen"
    Else
        If numer = 2 Then
            nazwaMiesiaca = "luty"
        Else
            If numer = 3 Then
                nazwaMiesiaca = "marzec"
            Else
                If numer = 4 Then
                    nazwaMiesiaca = "kwiecien"
                Else
                    If numer = 5 Then
                        nazwaMiesiaca = "maj"
                    Else
                        If numer = 6 Then
                            nazwaMiesiaca = "czerwiec"
                        Else
                            If numer = 7 Then
                                nazwaMiesiaca = "lipiec"
                            Else
                                If numer = 8 Then
                                    nazwaMiesiaca = "sierpien"
                                Else
                                    '(...)
                                End If
                            End If
                        End If
                    End If
                End If
            End If
        End If
    End If
End Function
Funkcja sklada sie z 12 warunków, z których kazdy kolejny zagniezdzony jest w poprzednim. Funkcja sprawdza najpierw czy podany jako argument wejsciowy numer miesiaca to 1. Jezeli warunek ten jest spelniony, funkcja otrzymuje wartosc styczen i konczy swoje dzialanie. W przeciwnym razie wykonywanie kodu przekazywane jest do bloku Else tego warunku, gdzie zagniezdzona jest kolejna instrukcja warunkowa, sprawdzajaca z kolei czy podany numer miesiaca to 2, itd.

Sam widzisz, ze zaprezentowana powyzej postac tej funkcji jest bardzo rozwlekla i czasochlonna. Ponadto przy zagniezdzaniu tak duzej ilosci instrukcji warunkowych bardzo latwo o pomylke (a przeciez miesiecy jest tylko 12, a moga zdarzyc sie funkcje, gdzie w ten sposób trzeba bedzie opisac kilkadziesiat jakichs obiektów).

Dodatkowo, jezeli chcesz zachowac przejrzystosc kodu i przy kazdej kolejnej instrukcji warunkowej stosowac nowe wciecie, to instrukcja warunkowa opisujaca grudzien nie miescilaby sie juz na ekranie, a zastosowanie w tej sytuacji przeniesienia tekstu do nowej linii za pomoca operatora  _ wprowadziloby w kodzie jeszcze wiekszy chaos.

Doskonalym sposobem na ominiecie opisanych niedogodnosci jest instrukcja Select Case.

Ponizej znajduje sie jeszcze jedna wersja funkcji nazwaMiesiaca, wykorzystujaca wlasnie te instrukcje. Dokladne wyjasnienie schematu dzialania polecenia Select Case znajdziesz pod ramka z kodem.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
Function nazwaMiesiaca(numer As Integer) As String

    Select Case numer
        Case 1
            nazwaMiesiaca = "styczen"
        Case 2
            nazwaMiesiaca = "luty"
        Case 3
            nazwaMiesiaca = "marzec"
        Case 4
            nazwaMiesiaca = "kwiecien"
        Case 5
            nazwaMiesiaca = "maj"
        Case 6
            nazwaMiesiaca = "czerwiec"
        Case 7
            nazwaMiesiaca = "lipiec"
        Case 8
            nazwaMiesiaca = "sierpien"
        Case 9
            nazwaMiesiaca = "wrzesien"
        Case 10
            nazwaMiesiaca = "pazdziernik"
        Case 11
            nazwaMiesiaca = "listopad"
        Case 12
            nazwaMiesiaca = "grudzien"
    End Select
End Function
Zastosowanie polecenia Select Case sprawia, ze kod jest o wiele bardziej przejrzysty, krótszy i latwiejszy do modyfikowania.

Instrukcja Select Case jest specyficznym rodzajem instrukcji warunkowej. Róznica pomiedzy zwykla instrukcja warunkowa, a instrukcja Select Case polega na tym, ze instrukcja If ... Then zawsze rozpatruje tylko jeden warunek, natomiast w instrukcji Select Caserozpatrywanych moze byc nieskonczenie wiele warunków i do kazdego z nich mozna przypisac operacje, jakie maja byc wykonane w przypadku jego spelnienia.

Instrukcja Select Case rozpoczyna sie od wiersza zawierajacego slowo kluczowe Select Case oraz wyrazenie, którego wartosc bedzie przez te instrukcje rozpatrywana. W opisywanym przykladzie rozpatrywany jest po prostu argument wejsciowy numer, ale role te, oprócz pojedynczej zmiennej, równie dobrze moze pelnic funkcja lub dzialanie arytmetyczne.

We wnetrzu instrukcji Select Case znajduja sie bloki opisujace operacje, jakie maja zostac wykonane dla poszczególnych wartosci wyrazenia bazowego. Tak jak wczesniej wspomniano, kazdy blok jest jakby oddzielnym warunkiem sprawdzanym przez instrukcje Select Case.

Blok rozpoczyna sie od slowa kluczowego Case i wartosci, dla której blok ten ma byc wykonywany. Jako wartosc przypisana do danego bloku mozna uzyc zmiennej, funkcji lub dzialania arytmetycznego, jednak w zdecydowanej wiekszosci przypadków stosowane sa w tej sytuacji po prostu recznie wpisane wartosci (tak jak w omawianym przykladzie).

Druga czescia bloku Case sa instrukcje, które maja byc wykonane przez makro, jezeli przypisany do niego warunek jest spelniony, czyli wyrazenie rozpatrywane przez instrukcje Select Case (w przykladzie jest to wartosc zmiennej numer) jest równe wartosci przypisanej do tego bloku (w przykladzie sa to numery poszczególnych miesiecy umieszczone po slowach kluczowych Case ). W powyzszym przykladzie dla kazego bloku zdefiniowano tylko jedno polecenie - przypisanie do zmiennej nazwaMiesiaca nazw poszczególnych miesiecy. Nie oznacza to jednak, ze kazdy blok musi ograniczac sie tylko do jednej operacji - w rzeczywistosci nie ma w tym zakresie zadnych ograniczen i kazdy blok moze zawierac dowolna liczbe operacji.

Kazdy blok konczy sie wraz z momentem rozpoczecia nastepnego bloku, a wiec po napotkaniu przez kod kolejnego slowa kluczowego Case (lub po natrafieniu na zamkniecie calej instrukcji Select Case, jezeli jest to ostatni blok w calej tej instrukcji).

Instrukcja Select Case konczy sie wierszem zamkniecia:  
End Select

Schemat dzialania instrukcji Select Case jest nastepujacy: po natrafieniu przez kompilator na wiersz otwarcia instrukcji Select Case, wyliczana jest aktualna wartosc okreslonego w nim wyrazenia (w omawianym przykladzie jest to zmienna numer, bedaca argumentem wejsciowym calej funkcji, wiec jej aktualna wartoscia bedzie wartosc podana przy wywolaniu tej funkcji). Nastepnie kompilator sprawdza kolejno wszystkie bloki opisane we wnetrzu instrukcji Select Case i jezeli stwierdzi, ze wartosc okreslona dla któregos z bloków jest równa wyliczonej wczesniej wartosci wyrazenia bazowego, wykonuje wszystkie polecenia zawarte w tym bloku, a nastepnie opuszcza cala instrukcje Select Case.

Jezeli wiec przykladowo, wywolujac funkcje nazwaMiesiaca, podales jako argument numer liczbe 3, to po wejsciu do instrukcji Select Case kompilator pominie dwa pierwsze bloki, poniewaz ich wartosci nie odpowiadaja wartosci wyrazenia bazowego, a nastepnie stwierdzi, ze wartosc trzeciego bloku spelnia ten wymóg, wykona wiec przewidziane dla tego bloku operacje (czyli przypisanie do zmiennej nazwaMiesiaca tekstu marzec), po czym opusci instrukcje Select Case nie sprawdzajac juz pozostalych bloków. Oprócz instrukcji Select Case opisywana funkcja nie zawiera juz zadnych innych polecen, wiec jej dzialanie w tym momencie dobiegnie konca i zwróci ona wartosc taka, jaka posiada zmienna nazwaMiesiaca (czyli przypisany przed chwila tekst marzec).

W sytuacji, gdy w pojedynczym bloku Case zawarta jest tylko jedna operacja, caly ten blok moze zostac zwiniety do jednego wiersza. Wówczas po okresleniu wartosci dla tego bloku, nalezy wstawic dwukropek, a nastepnie wpisac przewidziana dla tego bloku operacje.

Jako przyklad moga tu posluzyc bloki Case w instrukcji Select Case z poprzedniego przykladu, gdyz dla kazdego z nich byla wykonanywana tylko operacja przypisania odpowiedniej nazwy miesiaca do zmiennej nazwaMiesiaca. Caly poprzedni przyklad móglby wiec równie dobrze wygladac tak: 1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
Function nazwaMiesiaca(numer As Integer) As String

    Select Case numer
        Case 1: nazwaMiesiaca = "styczen"
        Case 2: nazwaMiesiaca = "luty"
        Case 3: nazwaMiesiaca = "marzec"
        Case 4: nazwaMiesiaca = "kwiecien"
        Case 5: nazwaMiesiaca = "maj"
        Case 6: nazwaMiesiaca = "czerwiec"
        Case 7: nazwaMiesiaca = "lipiec"
        Case 8: nazwaMiesiaca = "sierpien"
        Case 9: nazwaMiesiaca = "wrzesien"
        Case 10: nazwaMiesiaca = "pazdziernik"
        Case 11: nazwaMiesiaca = "listopad"
        Case 12: nazwaMiesiaca = "grudzien"
    End Select
End Function

Powrót do poczatku lekcji Laczenie kilku wartosci w pojedynczym bloku Case
Czesto zdarza sie, ze operacje wykonywane przez kilka bloków instrukcji Select Case sa dokladnie takie same. Przykladem takiej sytuacji jest ponizsza funkcja zwracajaca cene wynajmu miejsca w hotelu w zaleznosci od miesiaca.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
Function cenaWynajmu(miesiac As Integer) As Integer
    Select Case miesiac
        Case 1: cenaWynajmu = 40
        Case 2: cenaWynajmu = 40
        Case 3: cenaWynajmu = 40
        Case 4: cenaWynajmu = 55
        Case 5: cenaWynajmu = 55
        Case 6: cenaWynajmu = 70
        Case 7: cenaWynajmu = 70
        Case 8: cenaWynajmu = 70
        Case 9: cenaWynajmu = 60
        Case 10: cenaWynajmu = 40
        Case 11: cenaWynajmu = 40
        Case 12: cenaWynajmu = 40
    End Select
End Function
Jak widac w ramce z kodem, cena wynajmu zmienia sie trzykrotnie w ciagu roku i wynosi 40 zl w okresie od pazdziernika do marca, 55 zl w kwietniu i marcu, 70 zl od czerwca do sierpnia oraz 60 zl we wrzesniu.

W powyzszym kodzie wielokrotnie powtarzane sa te same instrukcje (np. cenaWynajmu = 40), co powinno byc ograniczone do absolutnego minimum. Na szczescie w tej sytuacji jezyk VBA umozliwia wyeliminowanie tych powtórzen, a tym samym znaczne skrócenie calego kodu, poprzez umieszczenie w tym samym bloku Case kilku wartosci, dla których wykonywany ma byc taki sam zestaw polecen.

Ponizej przedstawiono zmodyfikowana postac funkcji cenaWynajmu, w której znajduja sie juz tylko 4 bloki Case , za to wiekszosc z nich obowiazuje równoczesnie dla kilku wartosci wyrazenia bazowego. 1
2
3
4
5
6
7
8
Function cenaWynajmu(miesiac As Integer) As Integer
    Select Case miesiac
        Case 1, 2, 3, 10, 11, 12: cenaWynajmu = 40
        Case 4, 5: cenaWynajmu = 55
        Case 6, 7, 8: cenaWynajmu = 70
        Case 9: cenaWynajmu = 60
    End Select
End Function

W obecnej postaci kodu, przy niektórych slowach kluczowych Case wymienionych jest kilka wartosci, oddzielonych od siebie przecinkami. Kompilator sprawdzajac teraz, czy poszczególne bloki powinny byc wykonane, bierze pod uwage wszystkie wartosci przypisane do danego bloku. Jezeli którakolwiek z tych wartosci jest równa wartosci wyrazenia bazowego, wykonane zostaja operacje przewidziane dla tego bloku Case.

Nawet jezeli jakas wartosc zostanie przypisana równoczesnie do dwóch lub wiecej bloków Case, tak naprawde bedzie obowiazywala tylko dla pierwszego z nich. Dzieje sie tak, poniewaz po natrafieniu na blok zawierajacy wartosc wyrazenia bazowego, kompilator wykonuje operacje przewidziane dla tego bloku, a nastepnie opuszcza cala konstrukcje Select Case, nie sprawdzajac juz pozostalych bloków.

Przykladowo w ponizszym zapisie:
1
2
3
4
5
6
Sub Makro(numer As Integer)
    Select Case numer
        Case 1, 2, 3: Cells(1,1) = "liczba mniejsza od 4"
        Case 3, 4, 5: Cells(2,1) = "liczba wieksza od 2"
    End Select
End Sub
nawet jezeli argument wejsciowy numer bedzie wynosil 3, wykonana zostanie tylko operacja przewidziana dla pierwszego bloku, mimo ze dla wyrazenia bazowego równego 3 warunek zawarty w drugim bloku równiez bylby spelniony.

Z uwagi na opisany w powyzszej ramce schemat dzialania kodu w instrukcjach Select Case zawsze najlepiej jest umieszczac bloki Case w kolejnosci od najbardziej do najmniej prawdopodobnego.

Zalózmy przykladowo, ze funkcja cenaWynajmu w zdecydowanej wiekszosci jest wywolywana, aby sprawdzic cene pokoju dla miesiecy wakacyjnych, znacznie rzadziej dla miesiecy wiosennych oraz wrzesnia, a juz zupelnie rzadko dla pozostalych okresów roku. W takiej sytuacji warto jest przerobic ja do nastepujacej postaci: 1
2
3
4
5
6
7
8
Function cenaWynajmu(miesiac As Integer) As Integer
    Select Case miesiac
        Case 6, 7, 8: cenaWynajmu = 70
        Case 4, 5: cenaWynajmu = 55
        Case 9: cenaWynajmu = 60
        Case 1, 2, 3, 10, 11, 12: cenaWynajmu = 40
    End Select
End Function

Jedyna róznica pomiedzy obecna, a poprzednia postacia funkcji polega na innej kolejnosci bloków Case wewnatrz instrukcji Select Case. Zauwaz, ze w obecnej postaci funkcji, jezeli zapytanie dotyczy któregos z miesiecy wakacyjnych (a poczynione zostalo zalozenie, ze takie zapytania stanowia zdecydowana wiekszosc), kompilator juz przy pierwszym bloku Case stwierdzi, ze jest on spelniony, wykona przypisane do niego operacje i opusci instrukcje Select Case nie marnujac czasu na sprawdzanie pozostalych bloków. W poprzedniej wersji funkcji, zanim kompilator dotarl do bloku opisujacego miesiace wakacyjne, musial jeszcze wczesniej sprawdzic dwa inne bloki.

Oczywiscie w sytuacjach, kiedy jako argument miesiac podana bedzie np. liczba 2, to funkcja w tej postaci zadziala minimalnie wolniej niz poprzednio. Ale skoro, jak wczesniej ustalono, zapytania takie stanowia jedynie niewielka czesc wszystkich zapytan, to korzysci ze skrócenia czasu wykonania funkcji dla miesiecy wakacyjnych znacznie przewyzsza straty wynikajace z jego wydluzenia dla pozostalych sytuacji.

Zawsze warto jest wiec poswiecic troche czasu na zastanowienie sie, które bloki Case beda najczesciej spelnione i umieszczenie ich na samej górze instrukcji Select Case.

Nalezy w tym miejscu omówic jeszcze jedna wlasciwosc instrukcji Select Case, a mianowicie wykonywanie jakichs operacji w sytuacji, gdy zaden z bloków nie zostal spelniony (czyli odpowiednik sekcji Else w zwyklej instrukcji warunkowej If ... Then).

Zalózmy, ze omawiany w poprzednim przykladzie rozklad ceny wynajmu zostal zmieniony i teraz cena w czerwcu wynosi 65 zl, w lipcu - 70 zl, w sierpniu - 75 zl, a we wszystkich pozostalych miesiacach - 50 zl. Oczywiscie w takiej sytuacji równiez nalezy zastosowac instrukcje Select Case, a nie If ... Then, poniewaz w tym drugim przypadku konieczne byloby zagniezdzenie w sobie trzech warunków.

Kod funkcji cenaWynajmu wygladalby wiec teraz tak: 1
2
3
4
5
6
7
8
Function cenaWynajmu(miesiac As Integer) As Integer
    Select Case miesiac
        Case 1, 2, 3, 4, 5, 9, 10, 11, 12: cenaWynajmu = 50
        Case 6: cenaWynajmu = 65
        Case 7: cenaWynajmu = 70
        Case 8: cenaWynajmu = 75
    End Select
End Function

Zauwaz jednak, ze w pierwszym bloku Case wypisanych jest az 9 wartosci, a dodatkowo sa to wszystkie mozliwe wartosci jakie moze przyjac argument miesiac oprócz wartosci opisanych w pozostalych blokach (poniewaz numer miesiaca moze byc tylko liczba naturalna z zakresu 1-12).

W takiej sytuacji wygodnym rozwiazaniem jest wykorzystanie bloku Case Else. Blok Case Else jest odpowiednikiem bloku Else w zwyklej instrukcji warunkowej i okresla operacje do wykonania w przypadku niespelnienia zadnego ze zdefiniowanych warunków.

Funkcja cenaWynajmu po umieszczeniu w niej bloku Case Else wygladalaby tak, jak ponizej: 1
2
3
4
5
6
7
8
Function cenaWynajmu(miesiac As Integer) As Integer
    Select Case miesiac
        Case 6: cenaWynajmu = 65
        Case 7: cenaWynajmu = 70
        Case 8: cenaWynajmu = 75
        Case Else: cenaWynajmu = 50
    End Select
End Function

Teraz, gdy w instrukcji Select Case znajduje sie blok Case Else, schemat postepowania kodu w tej instrukcji wyglada nastepujaco: kompilator sprawdza po kolei wszystkie bloki zawarte w instrukcji Select Case i jezeli wartosc przypisana do któregos z bloku odpowiada wartosci wyrazenia bazowego to wykonuje operacje przewidziane dla tego bloku i opuszcza instrukcje Select Case. Jezeli natomiast zaden z bloków nie posiada wartosci równej wyrazeniu bazowemu, to po dotarciu do bloku Case Else kompilator wykonuje czynnosci opisane w tym bloku, niezaleznie od tego jaka jest wartosc wyrazenia bazowego.

Jezeli wiec miesiac podany jako argument przy wywolywaniu powyzszej funkcji bedzie pochodzil z zakresu wrzesien-maj, to w instrukcji Select Case ominiete zostana trzy pierwsze bloki i po dotarciu kodu do bloku Case Else wykonane zostana operacje przewidziane dla tego bloku, a wiec przypisanie do zmiennej cenaWynajmu wartosci 50.

Blok Case Else musi byc ostatnim blokiem w instrukcji Select Case.

Jezeli po bloku Case Else zostanie umieszczony jeszcze jakis inny blok, przy próbie uruchomienia makra zostanie wyswietlony komunikat Compile error: Case without Select Case.

Powrót do poczatku lekcji Wykorzystanie zakresów w blokach Case
Zdarzaja sie sytuacje, ze nawet mozliwosc umieszczenia kilku wyrazen w jednym bloku Case nie wystarcza, aby w pelni opisac wszystkie wartosci, jakie moze przyjac zmienna rozpatrywana przez instrukcje Select Case.

Za doskonaly przyklad moze tu posluzyc funkcja obliczajaca wysokosc podatku naliczanego wg skali progresywnej (przy obowiazujacych obecnie w Polsce dwóch progach podatkowych nie byloby potrzeby stosowania instrukcji Select Case, poniewaz swietnie nadaje sie do tego celu zwykla instrukcja warunkowa If ... Then; dlatego na potrzeby przykladu zalózmy, ze obowiazuja trzy progi podatkowe: 20%, 30% i 40% osiagane odpowiednio przy dochodach: 0 - 40 000, 40 000 - 80 000, ponad 80 000).

Oczywiscie niemozliwoscia byloby reczne wypisanie wszystkich mozliwych wartosci, przy których podatnik nalezy przykladowo do drugiego progu, gdyz zapis taki musialby wygladac mniej wiecej tak:  
Case 40000.01, 40000.02, 40000.03, 40000.04 ... 'itd.

Trzeba byloby w ten sposób wypisac wszystkie liczby, az do osiagniecia górnego pulapu tego progu, czyli kwoty 80 000 (na domiar zlego trzeba byloby poczynic zalozenie, ze przy wywolywaniu tej funkcji argument okreslajacy wysokosc pensji brutto nie zostanie podany z trzema lub wiecej miejscami po przecinku).

Ratunkiem jest w tej sytuacji kolejna bardzo przydatna wlasciwosc instrukcji Select Case - mozliwosc opisania w bloku Case zakresu wartosci.

Ponizej znajduje sie schemat funkcji wyliczajacej podatek, w którym do zdefiniowania poszczególnych bloków instrukcji Select Case wykorzystano zakresy liczb: 1
2
3
4
5
6
7
8
9
Function podatekDochodowy(pensjaBrutto As Single) As Single
    Select Case pensjaBrutto
        Case Is < 40000: podatekDochodowy = pensjaBrutto * 0.2
        Case Is < 80000
            podatekDochodowy = 8000 + (pensjaBrutto - 40000) * 0.3
        Case Else
            podatekDochodowy = 20000 + (pensjaBrutto - 80000) * 0.4
    End Select
End Function

Zwróc uwage, ze kazdy z zakresów opisujacych poszczególne bloki jest ograniczony tylko z jednej strony. W przypadku pierwszego bloku nie ma w tym nic dziwnego, poniewaz ma on byc wykonywany dla wartosci pensji brutto mniejszych od 40 000, wiec jednostronne ograniczenie zakresu (Is < 40000) jest jak najbardziej wskazane.

Drugi blok ma byc jednak wykonywany dla pensji brutto z przedzialu 40 000 - 80 000, natomiast, jak widzisz w kodzie, jedyne ograniczenie nalozone na jego wartosci jest takie, ze musza byc one mniejsze niz 80 000. Czy oznacza to, ze blok ten moze zostac wykonany takze dla wartosci mniejszych niz 40 000? Oczywiscie taka sytuacja nigdy sie nie wydarzy, a wynika to z opisywanego wczesniej schematu zachowania aplikacji po natrafieniu w kodzie na instrukcje Select Case. Jezeli argument pensjaBrutto bedzie mniejszy niz 40 000 to juz pierwszy blok (Case Is < 40000) bedzie spelniony i po jego wykonaniu kompilator opusci instrukcje Select Case w ogóle nie sprawdzajac czy spelnione sa kolejne bloki. Aby wiec wykonywanie kodu w ogóle dotarlo do drugiego bloku, zmienna pensjaBrutto nie moze byc mniejsza niz 40 000.

Jak wiec widzisz, za jedno z ograniczen zakresu przypisanego do bloku Case moga posluzyc zakresy zdefiniowane dla poprzedzajacych go bloków, tak jak ma to miejsce w powyzszym przykladzie, gdzie role dolnej granicy zakresu wartosci dla drugiego bloku (Case Is < 80000) pelni zakres przypisany do pierwszego bloku.

W ostatnim bloku Case nie ma juz potrzeby szczególowego opisywania wartosci, poniewaz ma on byc wykonywany dla wszystkich pozostalych wartosci pensji brutto, dzieki czemu mozna skorzystac z polecenia Case Else (oczywiscie zapis Case Is >= 80 000 równiez bylby poprawny, jednak uzyty w przykladzie zapis Case Else jest wygodniejszy w uzyciu).

Ogólny zapis bloku Case z zakresem wartosci ograniczonym jednostronnie przedstawia sie nastepujaco:  
 
 
 
Case Is > limit
Case Is >= limit
Case Is < limit
Case Is <= limit

Charakterystycznym elementem bloku z jednostronnym zakresem jest slowo kluczowe Is wystepujace pomiedzy poleceniem Case, a opisem limitu. Jezeli jednak przy definiowaniu jakiegos bloku zapomnisz wpisac tego slowa, a równoczesnie uzyjesz znaku mniejszosci (<) lub wiekszosci (>), edytor VBA domysli sie, ze chcesz okreslic wartosc za pomoca jednostronnego zakresu i automatycznie doda w odpowiednim miejscu slowo kluczowe Is.

Instrukcja Select Case umozliwia takze wykorzystanie w blokach Case zakresów ograniczonych z obu stron.

Aby przedstawic wykorzystanie tego typu zakresów w instrukcji Select Case jeszcze raz zostanie uzyta funkcja cenaWynajmu, zwracajaca koszt wynajmu miejsca w hotelu. Tym razem jednak, argumentem podawanym przy wywolywaniu funkcji jest data dzienna, a nie jak poprzednio numer miesiaca. Dzieki temu mozna bardziej szczególowo opisac zmiane ceny miejsca hotelowego i wziac pod uwage terminy, w których powinna byc ona wyzsza, np. dlugie weekendy (dla uproszczenia funkcja zwraca tylko ceny na rok 2011).

Funkcja cenaWynajmu wykorzystujaca w blokach Case zakresy danych przedstawia sie nastepujaco: 1
2
3
4
5
6
7
8
9
10
Function cenaWynajmu(data As Date) As Integer
    Select Case data
        Case #2011-01-01# To #2011-04-28#: cenaWynajmu = 40
        Case #2011-04-29# To #2011-05-03#: cenaWynajmu = 70
        Case #2011-05-04# To #2011-06-16#: cenaWynajmu = 55
        Case #2011-06-17# To #2011-08-28#: cenaWynajmu = 70
        Case #2011-08-29# To #2011-10-02#: cenaWynajmu = 55
        Case #2011-10-03# To #2011-12-31#: cenaWynajmu = 40
    End Select
End Function

Ogólny zapis bloku Case z dwustronnie ograniczonym zakresem wartosci wyglada nastepujaco:
 
Case x To y
gdzie x to dolna granica tego zakresu, a y - górna. Bardzo istotne jest zachowanie kolejnosci dolnego i górnego limitu, poniewaz w sytuacji gdy najpierw umiescisz wyzsza wartosc, a potem nizsza (np. Case 20 To 10), kompilator potraktuje to jako pusty zbiór i blok ten nigdy nie zostanie wykonany.

Przypisujac do bloku Case zakresy równiez mozesz korzystac z mozliwosci umieszczania w pojedynczym bloku kilku wyrazen.

Powyzsza funkcja cenaWynajmu zawiera przykladowo az 6 bloków Case, ale tak naprawde wykonuja one na przemian 3 operacje - przypisanie do funkcji wartosci 40 zl, 55 zl lub 70 zl. Nie ma wiec przeszkód, aby polaczyc ze soba bloki wykonujace te same operacje: 1
2
3
4
5
6
7
8
9
10
Function cenaWynajmu(data As Date) As Integer
    Select Case data
        Case #2011-01-01# To #2011-04-28#, #2011-10-03# To #2011-12-29#
                cenaWynajmu = 40
        Case #2011-04-29# To #2011-05-03#, #2011-06-17# To #2011-08-28#
                cenaWynajmu = 70
        Case #2011-05-04# To #2011-06-16#, #2011-08-29# To #2011-10-02#
                cenaWynajmu = 55
    End Select
End Function

Zasada laczenia kilku zakresów w jednym bloku jest dokladnie taka sama jak w przypadku laczenia pojedynczych wartosci - wystarczy po prostu wymienic po slowie kluczowym Case wszystkie obowiazujace dla tego bloku zakresy oddzielajac je od siebie przecinkami.

Nie ma tez zadnych przeszkód, aby w jednym bloku wymienic zarówno zakresy, jak i pojedyncze wartosci. Jezeli przykladowo do pierwszego bloku w powyzszej funkcji chcialbyc dodac jeszcze date 14 maja, wystarczyloby dopisac te date do listy wartosci zdefiniowanych dla tego bloku:  
Case #2011-01-01# To #2011-04-28#, #2011-10-03# To #2011-12-29#, #2011-05-14#

Powrót do poczatku lekcji Zagniezdzanie instrukcji Select Case
Instrukcja Select Case, podobnie jak inne omówione dotychczas instrukcje, smoze byc zagniezdzana. Zagniezdzanie instrukcji Select Case jest bardzo proste i wymaga po prostu wstawienia w bloku Case , nalezacym do jednej instrukcji, kolejnej instrukcji Select Case.

Przyklad makra zawierajacego zagniezdzone instrukcje Select Case przedstawiono ponizej. Jest to rozbudowana wersja omawianej wczesniej funkcji cenaWynajmu, która oprócz daty wynajmu bierze pod uwage wielkosc wynajmowanego pokoju.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
Function cenaWynajmu(data As Date, ileOsobWPokoju As Byte) As Integer
    Select Case data
        Case #2011-01-01# To #2011-04-28#, #2011-10-03# To #2011-12-29#
                Select Case ileOsobWPokoju
                        Case 2: cenaWynajmu = 46
                        Case 3: cenaWynajmu = 60
                        Case 4: cenaWynajmu = 72
                End Select
        Case #2011-04-29# To #2011-05-03#, #2011-06-17# To #2011-08-28#
                Select Case ileOsobWPokoju
                        Case 2: cenaWynajmu = 80
                        Case 3: cenaWynajmu = 99
                        Case 4: cenaWynajmu = 120
                End Select
        Case #2011-05-04# To #2011-06-16#, #2011-08-29# To #2011-10-02#
                Select Case ileOsobWPokoju
                        Case 2: cenaWynajmu = 60
                        Case 3: cenaWynajmu = 78
                        Case 4: cenaWynajmu = 92
                End Select
    End Select
End Function
Funkcja cenaWynajmu posiada teraz dwa argumenty wejsciowe: data oraz ileOsobWPokoju.

Wewnatrz funkcji znajduje sie instrukcja Select Case, która rozpatruje podana przy wywolywaniu funkcji date. W kazdym z bloków Case znajduje sie natomiast kolejna instrukcja Select Case, w której rozpatrywanym wyrazeniem jest wartosc zmiennej ileOsobWPokoju. Dopiero w tej zagniezdzonej instrukcji w blokach Case znajduja sie konkretne operacje wplywajace na wynik funkcji, czyli przypisanie do niej odpowiedniej ceny wynajmu.

Powrót do poczatku lekcji Wyliczenia
Czesto zdarza sie, ze przy wywolywaniu funkcji lub procedury, oprócz argumentów wejsciowych na podstawie których obliczane beda wyniki, potrzebny jest jeszcze jakis dodatkowy parametr okreslajacy sposób wykonania tej funkcji lub procedury.

Przykladem takiego dodatkowego parametru jest np. dzien uwazany za pierwszy dzien tygodnia podawany przy wywolywaniu funkcji Weekday, zwracajacej numer dnia tygodnia, lub rodzaj ikony jaka ma sie pojawic w oknie wyswietlanym przez funkcje MsgBox.

W takim przypadku konieczne jest okreslenie listy dostepnych wariantów danego parametru, dla których beda zdefiniowane odpowiadajace im operacje w kodzie. Zdefiniowac trzeba takze spójny system zapisu tych wariantów, tak aby w kazdym miejscu kodu byly one tak samo oznaczane i by kompilator nie mial problemu z ich interpretacja (np. dla parametru oznaczajacego dzien uwazany za pierwszy dzien tygodnia nie mozna podawac w jednym miejscu slowa poniedzialek, a w innym Monday - w kazdym miejscu kodu sposób zapisu musi byc jednakowy).

Byc moze na razie brzmi to troche zawile, ale wszystko powinno stac sie dla Ciebie jasniejsze po zapoznaniu sie z ponizszym przykladem.

Wrócmy do funkcji nazwaMiesiaca analizowanej na poczatku tej lekcji przy okazji omawiania instrukcji Select Case i zalózmy, ze funkcja ta ma zostac zmodyfikowana w taki sposób, aby przy jej wywolywaniu, oprócz argumentu okreslajacego numer miesiaca, dla którego ma byc zwrócona nazwa, podawany byl jeszcze drugi argument, okreslajacy jezyk, w którym nazwa tego miesiaca ma byc zwrócona. Funkcja bedzie umozliwiala uzyskanie nazwy miesiaca w jednym z trzech jezyków (polskim, angielskim i hiszpanskim), konieczne bedzie wiec zastosowanie zagniezdzonych instrukcji Select Case - jedna z tych instrukcji bedzie sprawdzala numer miesiaca, a druga jezyk, który podano przy wywolywaniu funkcji.

Jaki w ogóle typ powinien posiadac w tej funkcji argument jezyk? Na podstawie dotychczas zdobytej wiedzy, móglbys sie zastanawiac nad dwiema mozliwosciami - typem String lub któryms z typów liczbowych - niestety, oba te rozwiazania obarczone sa wadami, które szerzej opisano ponizej.

Jezeli argument jezyk zostanie zdefiniowany jako argument typu String, pierwsza przeszkoda pojawia sie juz przy budowaniu instrukcji Select Case, okreslajacej w jakim jezyku ma byc zwrócona nazwa miesiaca.

Jaka wartosc nalezy zdefiniowac dla bloku Case, aby kompilator wiedzial, ze chodzi przykladowo o jezyk polski? Zalózmy, ze dla opisania poszczególnych jezyków uzyles nazw polski, angielski i hiszpanski, a cala funkcja wyglada tak (dla skrócenia kodu w kazdym jezyku zapisano tylko 6 pierwszy miesiecy): 1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
Function nazwaMiesiaca(numer As Integer, jezyk As String) As String
    Select Case jezyk
        Case "polski"
                Select Case numer
                    Case 1: nazwaMiesiaca = "styczen"
                    Case 2: nazwaMiesiaca = "luty"
                    Case 3: nazwaMiesiaca = "marzec"
                    Case 4: nazwaMiesiaca = "kwiecien"
                    Case 5: nazwaMiesiaca = "maj"
                    Case 6: nazwaMiesiaca = "czerwiec"
                    'bloki dla kolejnych miesiecy
                End Select
        Case "angielski"
                Select Case numer
                    Case 1: nazwaMiesiaca = "January"
                    Case 2: nazwaMiesiaca = "February"
                    Case 3: nazwaMiesiaca = "March"
                    Case 4: nazwaMiesiaca = "April"
                    Case 5: nazwaMiesiaca = "May"
                    Case 6: nazwaMiesiaca = "June"
                    'bloki dla kolejnych miesiecy
                End Select
        Case "hiszpanski"
                Select Case numer
                    Case 1: nazwaMiesiaca = "enero"
                    Case 2: nazwaMiesiaca = "febrero"
                    Case 3: nazwaMiesiaca = "marzo"
                    Case 4: nazwaMiesiaca = "abril"
                    Case 5: nazwaMiesiaca = "mayo"
                    Case 6: nazwaMiesiaca = "junio"
                    'bloki dla kolejnych miesiecy
                End Select
        End Select
End Function

Budowa oraz schemat dzialania tej funkcji sa bardzo proste i, jezeli zapoznales sie z podrozdzialem dotyczacym zagniezdzania instrukcji Select Case, ich zrozumienie nie powinno przysporzyc Ci zadnych klopotów. Funkcja sklada sie z instrukcji Select Case, zawierajacej trzy bloki - kazdy opisujacy jeden z jezyków. W kazdym z tych bloków zagniezdzona jest kolejna instrukcja Select Case, która zawiera z kolei bloki z poszczególnymi numerami miesiecy.

Kompilator sprawdza wiec najpierw który jezyk zostal podany przy wywolaniu funkcji, a nastepnie, wewnatrz bloku przeznaczonego dla tego jezyka, wyszukuje podanego w argumencie numeru miesiaca i przypisuje do wyniku funkcji odpowiednia nazwe miesiaca.

Zauwaz, ze aby kompilator rozpoznal, jaki jezyk masz na mysli wywolujac te funkcje, musisz podac jego nazwe dokladnie w takiej postaci, w jakiej okresliles ja w odpowiednim bloku Case . Jezeli wiec chcesz przykladowo wyswietlic nazwe któregos miesiaca po hiszpansku, jako argument jezyk musisz podac wyraz hiszpanski, a nie hiszpanski, ESP czy jeszcze jakas inna forme. Oczywiscie bezposrednio po utworzeniu tej funkcji bedziesz pamietal o tej zasadzie i nie bedzie problemów z jej prawidlowym wywolaniem (aczkolwiek nawet wtedy moze sie przytrafic jakas literówka, która spowoduje zwrócenie blednej wartosci).

Wyobraz sobie teraz jednak, ze po kilku tygodniach w aplikacji korzystajacej z tej funkcji trzeba cos dodac lub poprawic, wiec po dlugiej przerwie ponownie musisz zajrzec do kodu tego makra (lub, co gorsza, musi do niego zajrzec ktos inny, kto nigdy wczesniej nie widzial go na oczy). Po kilku tygodniach prawdopodobnie nie bedziesz juz pamietal czy do bloku Case , opisujacego jezyk polski, przypisales tekst polski czy tez moze bylo to pol lub PL. Byc moze nie pamietalbys juz nawet, jakie jezyki sa w ogóle dostepne w funkcji nazwaMiesiaca.

Pozostaje Ci wiec albo odszukanie tej funkcji w kodzie i przeanalizowanie jej budowy, albo zgadywanie, jaka nazwa zostala zastosowana do zidentyfikowania bloku Case zawierajacego polskie nazwy miesiecy. Jezeli jednak uzyjesz nieprawidlowej nazwy i wywolasz funkcje przykladowo w takiej postaci:
 
nazwaMiesiaca(3, "pl")
kompilator w zaden sposób nie domysli sie, ze chcesz w ten sposób zwrócic polska nazwe miesiaca, poniewaz do zadnego bloku Case w funkcji nazwaMiesiaca nie przypisano wartosci pl. Wynikiem tej funkcji przy takich argumentach wejsciowych bylby wiec pusty ciag znaków.

Oczywiscie, jak pamietasz z podrozdzialu poswieconego rozbudowanym blokom Case , do pojedynczego bloku mozna przypisac kilka wartosci, zwiekszajac tym samym prawdopodobienstwo pózniejszego trafienia wlasciwej nazwy, np.  
Case "polski", "pol", "pl", "jezyk polski", "Polish"

Nigdy nie ma jednak gwarancji, ze wypiszesz wszystkie wartosci, które przyjda do glowy innym osobom korzystajacym z tej funkcji lub Tobie samemu podczas jej pózniejszego stosowania. Wlasciwie to jest niemal pewne, ze predzej czy pózniej ktos uzyje wartosci, której w tym bloku Case nie uwzgledniono.

Jeszcze gorszym pomyslem wydaje sie byc zastosowanie liczbowego typu zmiennej do okreslania, w jakim jezyku ma byc zwrócona nazwa miesiaca. W tym przypadku trzeba byloby najpierw przypisac do kazdego z dostepnych jezyków jakas liczbe, a potem stosowac te numeracje przy definiowaniu poszczególnych bloków w instrukcji Select Case oraz przy pózniejszym wywolywaniu tej funkcji.

Takie rozwiazanie jest jednak bardzo niewygodne i podatne na bledy, gdyz na dluzsza mete nie sposób zapamietac jaka liczba zostala przypisana do kazdego z jezyków, tym bardziej, jezeli w aplikacji znajdowaloby sie wiecej tego typu parametrów.

Wszystkich niedogodnosci zwiazanych z korzystaniem w podobnych sytuacjach ze zmiennych tekstowych lub liczbowych pozbawione sa natomiast wyliczenia.

Wyliczenie, zwane tez enumeracja, jest zestawem dopuszczalnych wartosci, jakie mozna przypisac do jakiegos parametru.

W omawianym przykladzie takim parametrem jest jezyk, a lista dostepnych wartosci sklada sie z trzech pozycji: jezyka polskiego, angielskiego i hiszpanskiego.

Postac ogólna wyliczenia wyglada nastepujaco:  
 
 
 
 
 
Enum Nazwa
    wartosc1 [=liczba]
    wartosc2 [=liczba]
    '(...)
    wartoscN [=liczba]
End Enum

Nazwa powinna jak najdokladniej okreslac parametr opisywany przez to wyliczenie. Mozesz ustalic sobie takze jakis skrót, który bedzie poprzedzal wszystkie deklarowane w kodzie wyliczenia, tak aby potem w trakcie pisania makr móc szybko przegladac ich liste (np. enumNazwaWyliczenia). Przykladowo, wszystkie wyliczenia fabrycznie zaimplementowane w VBA poprzedzone sa literami Vb, dzieki czemu korzystajac z autopodpowiedzi, po wpisaniu tych dwóch liter widzisz zgromadzona w jednym miejscu liste wszystkich wbudowanych wyliczen, tak jak to widac na ponizszym rysunku (zwróc przy okazji uwage na ikone symbolizujaca wyliczenie, pozwalajaca z latwoscia rozpoznac, które elementy znajdujace sie na liscie autopodpowiedzi sa wyliczeniami).

Wszystkie fabryczne wyliczenia VBA zgromadzone w jednym miejscu, dzieki poprzedzeniu ich nazw literami 'Vb'

We wnetrzu wyliczenia powinny zostac wypisane wszystkie wartosci dostepne dla opisywanego przez to wyliczenie parametru. W kazdej linijce powinna zostac umieszczona tylko nazwa opisujaca konkretny wariant parametru bez zadnych poprzedzajacych ja slów kluczowych. Do kazdej wartosci mozna ewentualnie przypisac jakas wartosc liczbowa, co czasami moze okazac sie bardzo przydatne (przyklady takich sytuacji zostana jednak przedstawione w dalszej czesci kursu).

Przy nadawaniu nazw wartosciom wyliczenia obowiazuja te same reguly, co przy nadawaniu nazw funkcjom i zmiennym. Dodatkowe zastrzezenie jest takie, ze w ramach jednego wyliczenia nie moga znalezc sie dwie wartosci o identycznych nazwach.

Blok definiujacy wyliczenie musi byc umieszczony u góry modulu, jeszcze przed rozpoczeciem jakiejkolwiek funkcji lub procedury.

Umieszczenie bloku z wyliczeniem za jakas funkcja lub procedura spowoduje, ze przy próbie uruchomienia makra zostanie wyswietlony blad: Compile error: Only comments may appear after End Sub, End Function or End Property.

Wyliczenie, które bedzie uzyte w analizowanej funkcji nazwaMiesiaca powinno wygladac nastepujaco:
1
2
3
4
5
Enum Jezyk
    polski
    angielski
    hiszpanski
End Enum
co oznacza, ze opisuje ono jezyki i udostepnia trzy warianty tego parametru: jezyk polski, angielski i hiszpanski.

Wiesz juz jak stworzyc w kodzie blok wyliczeniowy i zdefiniowac dostepne dla niego wartosci, najwyzszy wiec czas, abys dowiedzial sie, jak mozna to wyliczenie wykorzystac podczas pisania programu.

Kazde wyliczenie jest traktowane przez edytor VBA jak dodatkowy typ danych. Oznacza to, ze od tego momentu mozesz deklarowac zmienne jako typ Jezyk. Zauwaz, ze typ Jezyk pojawia sie tez od teraz na rozwijanej liscie dostepnych typów zmiennych (co pokazano na ponizszym rysunku):

Typ wyliczeniowy Jezyk na liscie autopodpowiedzi

Tak jak w przypadku kazdego innego typu zmiennych, zakres danych przyjmowanych przez typ Jezyk nie jest dowolny i ma pewne ograniczenia. Jak sie zapewne domyslasz, kazdy wyliczeniowy typ danych moze przyjmowac tylko takie wartosci, jakie zostaly zdefiniowane w bloku opisujacym to wyliczenie. W przypadku typu Jezyk zakres przyjmowanych przez zmienne wartosci bedzie wiec ograniczony do trzech wartosci: polski, angielski oraz hiszpanski.

Pamietaj, ze nazwy wyliczeniowe wypisywane sa w kodzie bez cudzyslowów, poniewaz nie sa one tekstami.

Teraz mozna zmodyfikowac funkcje nazwaMiesiaca tak, aby zamiast zmiennej tekstowej wykorzystywala do okreslania jezyka zmienna typu wyliczeniowego Jezyk. Nowa postac funkcji przedstawia sie nastepujaco (zmienione fragmentu kodu zostaly oznaczone na czerwono): 1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
Function nazwaMiesiaca(numer As Integer, jezyk As Jezyk) As String
    Select Case jezyk
        Case polski
                Select Case numer
                    Case 1: nazwaMiesiaca = "styczen"
                    Case 2: nazwaMiesiaca = "luty"
                    Case 3: nazwaMiesiaca = "marzec"
                    Case 4: nazwaMiesiaca = "kwiecien"
                    Case 5: nazwaMiesiaca = "maj"
                    Case 6: nazwaMiesiaca = "czerwiec"
                    Case 7: nazwaMiesiaca = "lipiec"
                    Case 8: nazwaMiesiaca = "sierpien"
                    Case 9: nazwaMiesiaca = "wrzesien"
                    Case 10: nazwaMiesiaca = "pazdziernik"
                    Case 11: nazwaMiesiaca = "listopad"
                    Case 12: nazwaMiesiaca = "grudzien"
                End Select
        Case angielski
                Select Case numer
                    Case 1: nazwaMiesiaca = "January"
                    Case 2: nazwaMiesiaca = "February"
                    Case 3: nazwaMiesiaca = "March"
                    Case 4: nazwaMiesiaca = "April"
                    Case 5: nazwaMiesiaca = "May"
                    Case 6: nazwaMiesiaca = "June"
                    Case 7: nazwaMiesiaca = "July"
                    Case 8: nazwaMiesiaca = "August"
                    Case 9: nazwaMiesiaca = "September"
                    Case 10: nazwaMiesiaca = "October"
                    Case 11: nazwaMiesiaca = "November"
                    Case 12: nazwaMiesiaca = "December"
                End Select
        Case hiszpanski
                Select Case numer
                    Case 1: nazwaMiesiaca = "enero"
                    Case 2: nazwaMiesiaca = "febrero"
                    Case 3: nazwaMiesiaca = "marzo"
                    Case 4: nazwaMiesiaca = "abril"
                    Case 5: nazwaMiesiaca = "mayo"
                    Case 6: nazwaMiesiaca = "junio"
                    Case 7: nazwaMiesiaca = "julio"
                    Case 8: nazwaMiesiaca = "agosto"
                    Case 9: nazwaMiesiaca = "septiembre"
                    Case 10: nazwaMiesiaca = "octubre"
                    Case 11: nazwaMiesiaca = "noviembre"
                    Case 12: nazwaMiesiaca = "diciembre"
                End Select
        End Select
End Function

W wierszu otwarcia funkcji zmienil sie tylko typ danych dla argumentu jezyk.

Zmienila sie takze wartosc dla kazdego z bloków Case w instrukcji Select Case rozpatrujacej zmienna jezyk. Wczesniej rozpatrywana przez te instrukcje zmienna jezyk byla zmienna typu tekstowego, dlatego tez do bloków Case przypisane byla wartosci tekstowe: polski, angielski oraz hiszpanski. Jednak w obecnej postaci funkcji, zmienna jezyk posiada typ wyliczeniowy Jezyk, w zwiazku z czym wartosci przypisane do poszczególnych bloków Case musza byc zgodne z tym typem. Nie moga wiec to byc dluzej zmienne tekstowe, poniewaz typ wyliczeniowy Jezyk (ani zaden inny typ wyliczeniowy) nie obsluguje zmiennych tekstowych. Jedyne wartosci dostepne dla tego typu danych to polski, angielski oraz hiszpanski, dlatego takie wlasnie wartosci sa teraz zdefiniowane dla bloków Case zamiast poprzednich wartosci tekstowych.

Spróbuj teraz wywolac w oknie Immediate gotowa juz funkcje nazwaMiesiaca (a wlasciwie prawie gotowa, bo w jednej z kolejnych lekcji, poswieconej tablicom, zostanie ona jeszcze bardziej udoskonalona).

Zwróc uwage, ze kiedy wpiszesz juz numer miesiaca i przejdziesz do okreslania jezyka, edytor VBA wyswietli rozwijana liste zawierajaca wszystkie dostepne warianty tego parametru. Nie ma wiec juz miejsca na zadna pomylke, nie musisz sie tez dluzej zastanawiac, jakie jezyki dostepne sa w tej funkcji, a dodatkowo nie musisz wpisywac calej nazwy definiujacej parametr, poniewaz mozesz po prostu wybrac go z listy.

Lista rozwijana ze wszystkimi dostepnymi wartosciami dla danego typu wyliczeniowego

Typy wyliczeniowe byly juz kilkakrotnie stosowane we wczesniejszych lekcjach tego kursu. Nalezaly do nich np. parametry okreslajace pierwszy dzien tygodnia i tydzien uwazany za pierwszy tydzien roku (wykorzystywane we wbudowanych funkcjach datowych) lub wszystkie parametry podawane dla argumentu Buttons w funkcji MsgBox.

Nalezy jeszcze w tym miejscu wrócic do opisanego w lekcji dziewiatej sposobu odczytywania przycisku wcisnietego przez uzytkownika w oknie MsgBox.

Z racji tego, ze nie znales jeszcze typów wyliczeniowych, w omawianym tam przykladzie wcisniety przycisk byl okreslany za pomoca zmiennej typu Integer. Teraz nie ma juz przeszkód, aby wykorzystac do tego celu typ wyliczeniowy VbMsgBoxResult, który jest wbudowanym typem wyliczeniowym przeznaczonym wlasnie do idetyfikacji przycisku wcisnietego przez uzytkownika w oknie MsgBox.

Omawiana w tamtej lekcji procedura wyswietlanieDaty moze wiec przyjac nastepujaca postac (standardowo zmienione fragmenty kodu oznaczono na czerwono): 1
2
3
4
5
6
7
8
9
10
Sub wyswietlanieDaty()
    Dim przycisk As VbMsgBoxResult

    przycisk = MsgBox("Czy chcesz wyswietlic w arkuszu aktualna godzine?", _
        vbYesNo + vbQuestion, "Potwierdzenie")

    If przycisk = VbYes Then
        Cells(1, 1) = Time
    End If
End Sub

Zmienna przycisk posiada teraz typ VbMsgBoxResult. Za kazdym razem, gdy jest ona wykorzystywana w kodzie, edytor VBA wyswietla liste wszystkich dostepnych dla niej wartosci, dzieki czemu bardzo latwo wybrac odpowiednia wartosc, a przytoczona w tamtej lekcji tabelka zawierajaca liczbowe odpowiedniki poszczególnych przycisków staje sie malo uzyteczna.